#!/usr/bin/env python3


# This script converts PNG images into Verilog modules that produce RGBA color
# values for a given X/Y pixel coordinate.  The red, green, and blue values can
# have varied depths, but the alpha channel is always a single bit.  The alpha
# bit is 1 if the pixel is fully opaque, and 0 otherwise.  In Verilog, if the
# alpha flag is 1, the pixel should be drawn.  If it is zero, it should be
# considered to be transparent.
#
# The resulting Verilog modules will take the form:
#
#       module image_imgname(x_pos, y_pos, r, g, b, a, width, height);
#
#   where x_pos and y_pos are pixel coordinates; r, g, b, and a are color
#   channels; and width/height are outputs set to the width/height of the image
#
# Author: Christopher Lutz


import errno
import math
import textwrap

from datetime import datetime
from os import mkdir
from sys import argv
from PIL import Image

# This function calculates colors for a pixel
# in an image and determines the output color
# determined by the specified color depth.
# This function assumes its inputs are 24-bit color
# PNGs with 8-bit colors per channel.
def get_colors(image, x, y, r_depth, g_depth, b_depth):
    color = image.getpixel((x, y))
    # Assuming 8-bit channels in source image
    r_depth_divider = math.pow(2, 8 - r_depth)
    g_depth_divider = math.pow(2, 8 - g_depth)
    b_depth_divider = math.pow(2, 8 - b_depth)
    r = int(color[0] // r_depth_divider)
    g = int(color[1] // g_depth_divider)
    b = int(color[2] // b_depth_divider)
    a = int(color[3] // 255)

    return [r, g, b, a]

# This function calculates all colors for pixels in
# an image and returns a dictionary of color->coordinate
# mappings
def calc_color_dictionary(image, coord_depth, r_depth, g_depth, b_depth):
    r_dict = {}
    g_dict = {}
    b_dict = {}
    a_dict = {}
    for y in range(0, image.height):
        for x in range(0, image.width):
            coord = (x << coord_depth) + y
            colors = get_colors(image, x, y, r_depth, g_depth, b_depth)
            if colors[0] not in r_dict:
                r_dict[colors[0]] = []
            r_dict[colors[0]].append(coord)
            if colors[1] not in g_dict:
                g_dict[colors[1]] = []
            g_dict[colors[1]].append(coord)
            if colors[2] not in b_dict:
                b_dict[colors[2]] = []
            b_dict[colors[2]].append(coord)
            if colors[3] not in a_dict:
                a_dict[colors[3]] = []
            a_dict[colors[3]].append(coord)
    return [r_dict, g_dict, b_dict, a_dict]

# This function takes an input image and
# converts it into its respective Verilog
# module for use in the VGA display modules
def convert(fname, out_fname, image, coord_depth, r_depth, g_depth, b_depth):
    dicts = calc_color_dictionary(image, coord_depth, r_depth, g_depth, b_depth)
    output(fname, image, out_fname, coord_depth, r_depth, g_depth, b_depth, dicts)
    print("\tConversion complete.")
    print("\t{} red value(s) used.".format(len(dicts[0])))
    print("\t{} green value(s) used.".format(len(dicts[1])))
    print("\t{} blue value(s) used.".format(len(dicts[2])))
    print("\t{} alpha value(s) used.\n".format(len(dicts[3])))

# This function converts integers into Verilog literals based
# on the width of the desired literal (i.e. 4 as a 3-bit-wide Verilog
# literal becomes 3'h4)
def int_to_verilog(value, bitwidth):
    return "{}'h{}".format(bitwidth, hex(value).upper()[2:].zfill(int(math.ceil(bitwidth / 4))))

# This function converts an array of integers into an array of strings
# where each string is the Verilog literal representation of the corresponding
# integer with the desired width (each integer is passed to int_to_verilog)
def int_array_to_verilog(array, bitwidth):
    result = []
    for value in array:
        result.append(int_to_verilog(value, bitwidth))
    return result

# This function constructs Verilog case entries and formats them so there are
# only three entries per line
def construct_case_entries(values):
    result = '';
    for index in range(0, len(values)):
        result += values[index]
        if index != len(values) - 1:
            result += ', '
        if index % 3 == 2 and index != len(values) - 1:
            result += "\n\t\t\t"
    return result

# This function constructs the 'case' statements for each color channel.
# If a color is constant throughout the entire image, it is simplified into
# a single assignment.
def build_cases(var, coord_depth, color_depth, channel_dict):
    if len(channel_dict) == 1:
        color = list(channel_dict.keys())[0]
        return "// Value 0x{} for entire image\n\t\t{} = {};".format(hex(color).upper()[2:], var, int_to_verilog(color, color_depth))
    else:
        cases = []
        for color in channel_dict:
            values = int_array_to_verilog(channel_dict[color], coord_depth * 2)
            cases.append("// Value 0x{}, {} total pixels\n\t\t\t{}: {} = {};\n".format(
                hex(color).upper()[2:],
                len(channel_dict[color]),
                construct_case_entries(values),
                var,
                int_to_verilog(color, color_depth)
            ))
        return "case (coordinate)\n\t\t\t{}\n\t\t\tdefault: {} = {};\n\t\tendcase".format("\n\t\t\t".join(cases), var, int_to_verilog(0, color_depth))

# This function fills in a Verilog template and writes it to the output file
def output(fname, image, out_fname, coord_depth, r_depth, g_depth, b_depth, color_dicts):
    file = open(out_fname, 'w')

    r_case = build_cases('r', coord_depth, r_depth, color_dicts[0])
    g_case = build_cases('g', coord_depth, g_depth, color_dicts[1])
    b_case = build_cases('b', coord_depth, b_depth, color_dicts[2])
    a_case = build_cases('a', coord_depth, 1, color_dicts[3])
    r_count = len(color_dicts[0])
    g_count = len(color_dicts[1])
    b_count = len(color_dicts[2])
    content = textwrap.dedent("""\
// *** THIS IS AN AUTO-GENERATED MODULE ***

/*
 * Source image: {0}
 * Image size: {1} x {2}
 * Color depth: {3} bits
 * Expected coordinate size: {4} bits
 *
 * Generated on {19} at {20}
 */

/*
 * Inputs/Outputs
 *  - [INPUT]  x_pos: {4}-bit X-coordinate
 *  - [INPUT]  y_pos: {4}-bit Y-coordinate
 *  - [OUTPUT] r:     {3}-bit red channel value
 *  - [OUTPUT] g:     {21}-bit green channel value
 *  - [OUTPUT] b:     {22}-bit blue channel value
 *  - [OUTPUT] a:     1-bit alpha channel flag (1 if solid, 0 if transparent)
 */
module {5}(x_pos, y_pos, r, g, b, a, width, height);
\tinput [{6}:0] x_pos, y_pos;
\toutput reg [{7}:0] r;
\toutput reg [{23}:0] g;
\toutput reg [{24}:0] b;
\t// Alpha channel is single-bit flag
\toutput reg a;
\toutput [{6}:0] width, height;

\t// Coordinates are combined x-y coordinates
\twire [{8}:0] coordinate;
\tassign coordinate = {{x_pos, y_pos}};

\t// Width/height outputs for graphics logic
\tassign width = {25};
\tassign height = {26};

\talways @ (*)
\tbegin

\t\t// ===================================={9}
\t\t// RED COLOR CHANNEL - {10} TOTAL VALUE(S)
\t\t// ===================================={9}

\t\t{11}

\t\t// ======================================{12}
\t\t// GREEN COLOR CHANNEL - {13} TOTAL VALUE(S)
\t\t// ======================================{12}

\t\t{14}

\t\t// ======================================{15}
\t\t//  BLUE COLOR CHANNEL - {16} TOTAL VALUE(S)
\t\t// ======================================{15}

\t\t{17}

\t\t// ==================
\t\t//  ALPHA COLOR FLAG
\t\t// ==================

\t\t{18}
\tend
endmodule""".format(
            fname,
            image.width,
            image.height,
            r_depth,
            coord_depth,
            out_fname.split('.')[0],
            coord_depth - 1,
            r_depth - 1,
            (coord_depth) * 2 - 1,
            '=' * len(str(r_count)),
            r_count,
            r_case,
            '=' * len(str(g_count)),
            g_count,
            g_case,
            '=' * len(str(b_count)),
            b_count,
            b_case,
            a_case,
            datetime.now().strftime('%B %-d, %Y'),
            datetime.now().strftime('%-I:%M:%S %p'),
            g_depth,
            b_depth,
            g_depth - 1,
            b_depth - 1,
            int_to_verilog(image.width, coord_depth),
            int_to_verilog(image.height, coord_depth)
        )
    )
    file.write(content + "\n")
    file.close()

# =====================
#  PROGRAM ENTRY POINT
# =====================

images = []
r_depth = 0
g_depth = 0
b_depth = 0
coord_depth = 0

# Read in command line arguments
argv.pop(0)
for arg in argv:
    if arg.startswith('--'):
        option = arg[2:].split('=')[0]
        value = int(arg[2:].split('=')[1])
        if option == 'rdepth':
            r_depth = value
        elif option == 'gdepth':
            g_depth = value
        elif option == 'bdepth':
            b_depth = value
        elif option == 'xywidth':
            coord_depth = value
        else:
            print("Unknown option '{}'.".format(option))
    else:
        images.append(arg)

# Check for all necessary options
if r_depth == 0:
    print('Red channel depth must not be zero (use --rdepth=?? option).')
elif g_depth == 0:
    print('Green channel depth must not be zero (use --gdepth=?? option).')
elif b_depth == 0:
    print('Blue channel depth must not be zero (use --bdepth=?? option).')
elif coord_depth == 0:
    print('Coordinate bit width must not be zero (use --xywidth=?? option).')
else:
    print("Red channel depth:   {}".format(r_depth))
    print("Green channel depth: {}".format(g_depth))
    print("Blue channel depth:  {}".format(b_depth))
    print("Coordinate depth:    {}".format(coord_depth))
    print()

    # For each image name, load the image and convert it into Verilog
    # Output filenames are 'image_<image name>.v' where <image name>
    # is the file name for the image without an extension and where all
    # dashes or spaces are replaced with underscores (i.e. file-1.png becomes
    # image_file_1.v)
    for fname in images:
        folder_split = fname.split('/')
        out_fname = 'image_' + folder_split[len(folder_split) - 1].split('.')[0].replace('-', '_').replace(' ', '_') + '.v'
        image = Image.open(fname).convert('RGBA')

        print("Image: {} ({} x {})".format(fname, image.width, image.height))
        print("\tConverting into {}...".format(out_fname))

        convert(fname, out_fname, image, coord_depth, r_depth, g_depth, b_depth)
